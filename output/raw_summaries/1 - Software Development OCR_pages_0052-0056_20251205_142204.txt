LEARNING GUIDE: Pages 52-56
Generated: 2025-12-05 14:22:04
PDF: 1 - Software Development OCR

================================================================================
LEARNING GUIDE
================================================================================

Here is a simplified, easy-to-read learning guide based on the provided text:

---

## Software Development Learning Guide

### 1. Minimum Spanning Tree (MST)

**Key Concepts:**
*   **Spanning Tree:** A tree that connects all vertices in an undirected, weighted graph without containing any cycles.
*   **Minimum Spanning Tree (MST):** A spanning tree where the sum of its edge weights is the absolute minimum possible.
*   **Purpose:** Find the most "economical" way to connect all parts of a graph.

**Common Algorithms for MST:**
1.  **Kruskal's Algorithm:**
    *   **Method:** Selects edges with the smallest weights.
    *   **Process:**
        1.  Start by selecting the edge with the smallest weight from the entire graph.
        2.  Sequentially select the next smallest weighted edge.
        3.  **Crucial Check:** Before adding an edge, ensure it does not create a cycle with already selected edges. If it creates a cycle, skip it.
        4.  Continue until all vertices are connected (n-1 edges for n vertices).
2.  **Prim's Algorithm:**
    *   **Method:** Grows the MST from a starting vertex.
    *   **Process:**
        1.  Select a random starting vertex from the graph.
        2.  In each iteration, select the edge with the minimum weight that connects a vertex already in the MST to a vertex not yet in the MST.
        3.  Add the new vertex and edge to the MST.
        4.  Repeat until all vertices are included in the MST.

---

### 2. Software Design Fundamentals

**Recent Trends & Issues:**
*   **Quality is Key:** Software design is directly linked to software quality.
*   **Early Control:** Performing quality control and prevention in the analysis and design phases significantly reduces the cost of potential software failures.
*   **Requirement Analysis:** A good design process starts with thorough requirement analysis.

**Learning Objectives:**
*   Understand software design principles.
*   Explain cohesion and coupling as module evaluation criteria.
*   Understand structural design methods and content.

**Keywords:**
*   Division, Abstraction, Information Hiding, Stepwise Refinement, Modularization, Structuralization
*   Cohesion, Coupling
*   Transform-based Design, Transaction-based Design, Structure Chart

---

### 3. Case Study: Ariane 5 Explosion (Importance of Design)

**Event:** Ariane 5 rocket exploded on June 4, 1996, shortly after launch.
**Root Cause (Software Design Faults):**
*   **Inadequate Exception Handling:**
    *   A 64-bit real-type value was input into a system designed for 16-bit integers.
    *   No exception handling was implemented for this integer-type conversion error, leading to an overflow.
    *   This caused critical altitude and velocity information to be lost.
*   **Insufficient Redundancy Design:**
    *   When one system (SRI-2) failed, the redundant system (SRI-1) should have taken over.
    *   However, the architecture was designed such that the input value error affected both redundant systems, rendering the redundancy ineffective.
*   **Omitted Exceptions:** Three out of seven critical exception handlers were intentionally omitted to meet a load target, which proved disastrous.

**Consequences:** Loss of control over engine nozzle angle and thrust, leading to deviation and explosion.
**Key Takeaway:** High-quality software design is crucial and is not guaranteed by design alone. It requires:
*   **Comprehensive Testing:** Use cases reflecting the widest possible test range (e.g., boundary value analysis).
*   **Iterative Refinement:** Continuously supplementing and refining the design based on testing and defect discovery.

---

### 4. Principles of Software Design

**General Principle: Divide and Conquer (Modularization)**
*   **Goal:** Reduce complexity of problem areas.
*   **Method:** Continuously divide user requirements into smaller, manageable pieces.
*   **Process:** Group results based on independence and dependence of roles.
*   **Subsystems:** Higher-level divisions of a system that can perform functions and be compiled independently. They enable multiple designers to work on different parts simultaneously and facilitate easier integration later.

**A) Abstraction**
*   **Definition:** Considering product implementation at a higher level first, focusing on essential matters and omitting non-essential details.
*   **Purpose:** To gradually approach a problem while maintaining a larger flow, making it easier to handle complexity.
*   **Types:** Data abstraction, control abstraction, process abstraction.
*   **Focus:** Understanding how components interact externally (their interface) rather than their detailed internal implementation.

**B) Information Hiding**
*   **Definition:** Each module's internal content is hidden from other modules; communication occurs only through predefined interfaces.
*   **Purpose:**
    *   Limits access to internal information.
    *   Ensures changes in one module affect a minimum number of other modules.
    *   Keeps modules independent of each other.
*   **Mechanism:** It's a fundamental design principle, not necessarily requiring a specific programming language feature.
*   **Benefit:** Easier system maintenance and modification because changes are localized within modules.

**C) Stepwise Refinement**
*   **Definition:** Gradually moving from a high-level program structure to low-level module details.
*   **Process:** Decreasing the level of abstraction, decomposing functions to present detailed solutions.
*   **Application:** Applies throughout the entire engineering process: from problem description to requirements analysis, design, and programming.
*   **Example:** Starting with a large process and progressively subdividing it into smaller, more detailed functional processes.

**D) Modularization**
*   **Definition:** Dividing a system into distinct components called modules (e.g., subroutines, procedures, functions).
*   **Approach:** Often uses a top-down approach, creating control layers between modules.
*   **Benefits:**
    *   Manages system complexity effectively (applying "Divide and Conquer").
    *   Solves large and complex problems by breaking them into smaller units.
    *   Facilitates easier system maintenance and modification.
*   **Considerations (Drawbacks if not managed well):**
    *   Too many modules can decrease individual module size, potentially leading to performance deterioration.
    *   Increased inter-module exchange can cause overload.
*   **Evaluation Criterion:** Minimize interference between modules while maximizing their effective contribution to their specific purpose.

**E) Structuralization**
*   **Definition:** Organizing software systems based on the division process (related to "Divide and Conquer").
*   **Stages:**
    *   **Requirements Analysis:** Initial high-level division of system elements or functions.
    *   **Design Phase:** Detailed division and structuralization of the analysis results.
*   **Roles:**
    *   **Analysts:** Identify and divide key system elements/functions.
    *   **Designers:** Structuralize these identified elements.
*   **Guidelines:** There are no universal, complete guidelines for how to perfectly divide a system. Designers rely on experience and characteristics/structural frames of existing similar systems to reduce time and effort.

---

================================================================================
ORIGINAL TEXT (First 5000 chars)
================================================================================

--- Page 52 ---
Software  Development )
H) Minimum  spanning  tree
@ Introduction  to the minimum  spanning  tree
A spanning  tree is a special form of tree that includes  and connects  all vertices  in an undirected  weighted
graph. This tree should not contain a cycle. A minimum  spanning  tree is a spanning  tree whose sum of
weighted  values is the minimum.  Kruskal’s  algorithm  and Prime’s algorithm  are representative  algorithms  that
implement  a minimum  spanning  tree.
@ Kruskal’s  algorithm
An edge with the smallest  weighted  value is selected  from among the edges connected  to the vertex, and
it is checked whether  the added edge creates a cycle. Edges with a smaller weighted  value are selected
sequentially,  even though the edge with the smallest  weighted  value is selected  but not connected  to the
vertex.
@ Prim’s algorithm
A random vertex is selected  from the graph to be analyzed.  Then, a new vertex and an edge which have not
been visited before are selected  for each iterative  process  and expanded in the minimum  spanning  tree that
has been composed  up to that point.
M1 Software  development  51


--- Page 53 ---
ESSENCE
>> Recent  trends and major issues
The world has now entered a new era of limitless  quality competition,  and software  cannot be an
exception  to the rule. Software  design is closely related to software  quality. In this respect,  we can
see that efforts to analyze  the requirements  are also a process  for good design. The cost possibility
of software failure can be significantly  reduced if quality control and prevention  activities  are
performed  frequently  in the analysis  and design phase.
>> Learning  objectives
1. To be able to describe  the types and contents  of software design  principles  that should be
considered  when designing  software.
2. To be able to explain the concepts  of cohesion  and coupling,  which are the criteria for evaluating
the design of a module.
3. To be able to understand  structural  design methods  and express  design contents.
>> Keywords
- Division,  abstraction,  information  hiding, stepwise  refinement,  modularization,  structuralization
- Cohesion,  coupling
- Transform-based  design, transaction-based  design, structure  chart
52 TOPCIT  ESSENCE


--- Page 54 ---
Software  Development )
+ Preview  for practical  business Ariane 5’s explosion  attributable  to
poor software  design
Software  passes through a design process  that consists  in abstracting  the analyzed  requirements
into a computer  world. The design process  should include  the method  of handling  numerous  variables
defined  for the design, the variable  types used by an input value, and exceptions  due to error values.
Software  design faults are sometimes  eliminated  while repeating  tests such as boundary  value
analysis.  In addition,  redundant  data and server configuration  to cope with an emergency  should also
be designed  to support  the process  stably.
The Ariane 5 rocket exploded  during its launch on June 4, 1996 due to an inadequate  exception
design against  a mismatch  of the variable  types and insufficient  consideration  of redundancy  design.
The variable  types in the design were 16-bit integers,  yet 64-bit real type was entered.  However,
exception  handling  for integer-type  conversion  errors was not fully reflected  in the design, causing
overflow,  As a result, altitude  and velocity  information  was not sent to the central control  computer.
When a failure  occurred  in one SRI-2, the redundant  SRI-1 should have been activated. However,
as the architecture  was designed  in this way, There could be no effect due to an input value error.
Eventually,  Ariane 5 deviated  from its course and exploded  because  its engine nozzle angle and
thrust could not be controlled.
According  to the eventual  findings,  three exceptions  out of seven items were omitted  from Ariane 5
to achieve the SRI’s maximum  load target of 80%. As a result, it is said that software  development
was forced to bear all the responsibility  for the failure. After all, high-quality  software  design is not
guaranteed  by the design itself. To complete  high-quality  software, use cases that ensure the widest
possible test range should be reflected  in the development  and testing process,  which in turn will
make up for unexpected  defects.  This process  of supplementing  the design should be repeated.
M1 Software  development  53


--- Page 55 ---
ESSENCE
01 Principles  of Software  Design
The complexity  of the problem area should be reduced by continuously  dividing  the user requirements
in the software  design phase, and its results should be reassembled  as proper  groups by considering  the
independence  and dependence  of the role unit. This task is also expressed  as the basic design principle  of “Divide
and Conquer”.  Complex  problems  can be solved more easily if we mentally  divide a system into separate
pieces, Also, if the function...
