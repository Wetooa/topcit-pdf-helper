LEARNING GUIDE: Pages 55-59
Generated: 2025-12-05 14:22:23
PDF: 1 - Software Development OCR

================================================================================
LEARNING GUIDE
================================================================================

Here's a simplified, easy-to-read learning guide for software design principles, cohesion, and coupling, based on the provided text.

---

## Software Design Principles: A Learning Guide

This guide covers essential principles for designing software, focusing on creating efficient, maintainable, and adaptable systems.

---

### **1. Principles of Software Design**

The core idea in software design is to **reduce complexity** by breaking down user requirements into smaller, manageable pieces, then reassembling them logically. This is known as **"Divide and Conquer"**.

*   **Subsystem:** A higher-level program component that performs functions and can be compiled independently. Dividing a system into subsystems allows multiple designers to work simultaneously and facilitates easier integration later.

#### **A) Abstraction**
*   **Definition:** Focusing on essential aspects at a higher level, gradually adding details as needed. It means omitting non-essential information to simplify understanding.
*   **Purpose:** To manage complexity by showing only what's necessary.
*   **Process:** Engineering moves from high (general) to low (detailed) levels of abstraction.
*   **Focus:** Understanding external interfaces and behavior before internal implementation details.
*   **Types:** Data, Control, and Process Abstraction.

#### **B) Information Hiding**
*   **Definition:** Concealing the internal details of a module, allowing other modules to interact only through a defined **interface**.
*   **Benefit:**
    *   **Minimizes impact of changes:** A change inside one module affects only that module, preventing a "ripple effect" across the system.
    *   **Increases module independence:** Modules don't need to know each other's internal workings.
*   **Key Idea:** Modules communicate via predefined interfaces, not by directly accessing internal structures.

#### **C) Stepwise Refinement**
*   **Definition:** A gradual process of moving from a high-level program structure to detailed module specifics. The level of abstraction decreases as details are added.
*   **Analogy:** Moving from a general problem description through requirements analysis, design, and programming is a form of stepwise refinement.
*   **Method:** Decomposing large processes into smaller, more detailed functions.

#### **D) Modularization**
*   **Definition:** Dividing a system into independent, functional units called **modules** (also known as subroutines, procedures, or functions).
*   **Approach:** Often uses a top-down approach, breaking functions into smaller parts.
*   **Benefits:**
    *   Manages system complexity (Divide and Conquer).
    *   Easier maintenance and modification.
*   **Potential Drawback:** Too many modules can decrease performance and increase overhead due to inter-module communication.
*   **Goal:** Minimize interference between modules by clearly defining their roles and purposes.

#### **E) Structuralization**
*   **Definition:** Organizing the divided system elements into a clear structure.
*   **Process:** Division starts during requirements analysis, with detailed structuring occurring in the design phase.
*   **Roles:** Analysts identify and divide system elements; designers structure these results.
*   **Guidance:** Experience and existing system frameworks (structural frames) help in effectively dividing and structuring systems.

---

### **2. Cohesion and Coupling: Quality Metrics for Design**

A **good design** is efficient, adaptable to changes, and localizes the impact of those changes. This is achieved by maximizing functional independence and minimizing module interdependencies.

#### **A) Cohesion**
*   **Definition:** A measure of the **strength of internal relationships** within a module. It indicates how well the elements within a module belong together to achieve a single, common purpose. (Think of it as the "glue" holding a module's parts together).
*   **Goal:** **High cohesion** is desirable. Modules should perform a single logical function or represent a single logical entity.
*   **Relationship with Coupling:** High cohesion within a module often leads to low coupling between modules.
*   **Cohesion Spectrum:** Strongest `«--------------------------------------------- >` Weakest

    *   **Functional Cohesion (Strongest):** All elements contribute to a single, well-defined function. *(Ideal)*
    *   **Sequential Cohesion:** Output of one activity in the module serves as input for the next.
    *   **Communication Cohesion:** Components performing different functions use the same input/output data.
    *   **Procedural Cohesion:** Module contains multiple related functions performed sequentially.
    *   **Temporal Cohesion:** Functions grouped because they are processed at the same time (e.g., initialization module).
    *   **Logical Cohesion:** Elements are grouped based on similar characteristics or type, but may perform different actions.
    *   **Coincidental Cohesion (Weakest):** Module contains completely unrelated elements. *(Avoid)*

#### **B) Coupling**
*   **Definition:** A measure of the **complexity and strength of dependencies** between different modules. It indicates how much modules rely on each other.
*   **Goal:** **Weak coupling** is desirable. Modules should be as independent as possible.
*   **Problems of Strong Coupling:**
    *   **Difficulty in independent changes:** Changing one module often requires changes in many others.
    *   **Ripple effect:** Changes propagate widely, making maintenance difficult.
*   **Practical Advice:** Use parameters for communication instead of global variables to reduce coupling.
*   **Coupling Spectrum:** Weakest `«--------------------------------------- >` Strongest

    *   **Data Coupling (Weakest):** Modules communicate by passing only necessary data elements as parameters/arguments. Changes in one module do not affect others. *(Most desirable)*
    *   **Stamp Coupling:** Modules pass entire data structures (e.g., records, objects) as parameters. If the structure changes, all modules receiving it are affected, even if they only use part of it.
    *   **Control Coupling:** One module passes a "control flag" or "switch" to another, influencing its logical flow. The calling module dictates the called module's internal logic.
    *   **External Coupling:** Modules reference externally declared data (global variables outside their direct control). Limits scope of referenced data.
    *   **Common Coupling:** Modules share a common global data area. Changes to this shared data affect all modules using it, weakening independence.
    *   **Content Coupling (Strongest):** One module directly refers to or modifies the internal data or code of another module (e.g., branching into another module's middle). *(Must be avoided)*

---

================================================================================
ORIGINAL TEXT (First 5000 chars)
================================================================================

--- Page 55 ---
ESSENCE
01 Principles  of Software  Design
The complexity  of the problem area should be reduced by continuously  dividing  the user requirements
in the software  design phase, and its results should be reassembled  as proper  groups by considering  the
independence  and dependence  of the role unit. This task is also expressed  as the basic design principle  of “Divide
and Conquer”.  Complex  problems  can be solved more easily if we mentally  divide a system into separate
pieces, Also, if the functions  are divided, or the user interface  is logically  divided, an easier solution can be
found.
In general, a system component  divided at a higher level is called a subsystem.  The subsystem is a program
component  that can perform  functions  and be compiled  independently.  The subsystem  means that a system
has been divided at a higher level of the system structure.  System designers  divide a problem  into subsystems
so that several designers  and designers  can develop  different  subsystems  independently  later on. The clarity
of the split process is pursued  to make the entire system work smoothly,  and to facilitate  the integration  of
subsystems  developed  by different  developers  at a later date.
A) Abstraction
Abstraction  means considering  product  implementation  at a higher level first, rather than concerning  oneself
with implementation  at a detailed  level, in order to access a problem  area gradually  while maintaining  a larger
flow. Abstraction  enables  us to express  only essential  matters  that are easy to handle, because  abstraction
eliminates  details that are of no interest  to us or are not essential.  Abstraction  is an important  principle
that is applied throughout  the entire engineering  process.  Engineering  is a process  of moving from a higher
abstraction  level to a low level. The types of abstraction  can be divided into data abstraction,  control
abstraction,  and process  abstraction.
We need to understand  how components  (or modules)  interact  with each other and the behavior  that
manifests  itself outside  when a system is divided, before understanding  how the components  are implemented
inside in detail. That is, the concept  of abstraction  is based on focusing  on the external  interface  by daring to
omit methods  of component  implementation.
B) Information  hiding
Information  hiding is based on the concept  that the content  of each module is hidden, and that messages
can be transmitted  by the interface  only. It is designed  in such a way that one module or subsystem  does
not affect other modules,  by limiting  access to internal information.  For example,  when a change  occurs in
the design process,  information  hiding ensures  that the change  affects the minimum  number  of modules  only.
That is, if a module is defined by an interface  with the outside,  and detailed  information  including  the internal
structure  or progress  of the module  is hidden from other modules,  the information  is hidden. Information  hiding
keeps the modules  independent  of each other.
Information  hiding does not necessarily require a programming  language equipped  with an information  hiding
mechanism.  Rather, it is a basic principle  for designing  software,  and the concept  of information  hiding is
important  in system design in that it keeps the components  independent  of each other. Information  hiding
hides the internal  structure  of each module  (abstraction),  and the modules  communicate  with each other using
the predefined  interface  only, without  needing  to know the internal  structure.  If a module  needs to be modified,
54 TOPCIT  ESSENCE


--- Page 56 ---
Software  Development )
changes  can be limited to the data structure inside the module and the actions needed to access it, so that
users can easily adapt themselves  to the change  and perform  maintenance.
C) ) Stepwise  refinement
Stepwise  refinement  is realized by gradually  moving from the program  structure  to the module details. The
level of abstraction  decreases  during the refining process, and each function is decomposed  to present  a
solution.  Refinement  is a process  that requires  many efforts and enables  system implementation  by allowing  a
detailed  description.
Design is the stepwise  refinement  process  of moving  from a high abstraction  level to a low abstraction  level.
The flow of engineering,  ranging  from problem  description  to requirements  analysis,  design and programming,
can also be regarded  as a stepwise  refinement  process.  Another  example  of stepwise  refinement is one in
which a system is started as a big process  and gradually  subdivided  into small processes  that perform  detailed
functions,  using the structural  analysis  method.
D) Modularization
In most cases, engineering  approaches  a system by dividing  it into components.  The component  of software  is
a module.  When expressed  in a programming  language, ...
