LEARNING GUIDE: Pages 10-14
Generated: 2025-12-05 10:40:20
PDF: 2 - Understanding and Using Data OCR

================================================================================
LEARNING GUIDE
================================================================================

This learning guide summarizes key concepts from database design, normalization, physical implementation, quality, and query languages. It's designed to be concise and easy to study.

---

## Learning Guide: Database Concepts

### V. Data Modeling Basics

#### 06. Entity-Relationship (ER) Modeling Fundamentals

*   **A) Entity, Attribute, Identifier**
    *   **Entity:** A real-world object or concept that stores data (e.g., `Customer`, `Product`). Represented as a table.
    *   **Attribute:** A property or characteristic of an entity (e.g., `CustomerName`, `ProductID`). Represented as a column in a table.
    *   **Identifier:** An attribute or set of attributes that uniquely identifies an entity instance (e.g., `CustomerID`). This becomes the Primary Key.

*   **B) Characteristics of the Entity**
    *   Must have a unique existence.
    *   Must have attributes.
    *   Must have at least one identifier.
    *   Can participate in relationships with other entities.

*   **C) Classification of Entities**
    *   **Strong Entity:** Can exist independently, has its own primary key (identifier).
    *   **Weak Entity:** Existence depends on another entity (owner entity), identifies itself through a foreign key from the owner entity and its own partial key.

*   **D) Classification of Attributes**
    *   **Simple Attribute:** Cannot be broken down further (e.g., `Age`).
    *   **Composite Attribute:** Can be broken into smaller parts (e.g., `Address` into `Street`, `City`, `Zip`).
    *   **Single-valued Attribute:** Has only one value for an entity instance (e.g., `EmployeeID`).
    *   **Multi-valued Attribute:** Can have multiple values for an entity instance (e.g., `PhoneNumbers` for a person).
    *   **Derived Attribute:** Value can be calculated from other attributes (e.g., `Age` from `DateOfBirth`).

*   **E) Relationship**
    *   An association between two or more entities.
    *   Represents how entities interact (e.g., a `Customer` *places* an `Order`).

*   **F) How to Read Relationships (Cardinality and Participation)**
    *   **Cardinality:** Describes the number of instances of one entity associated with instances of another entity (e.g., one-to-one (1:1), one-to-many (1:N), many-to-many (M:N)).
    *   **Participation:** Indicates whether an entity instance *must* participate in a relationship (mandatory) or *can* participate (optional).

*   **G) Characteristic of the Identifier (Key)**
    *   **Uniqueness:** Each value identifies one unique entity instance.
    *   **Minimality:** Contains the fewest possible attributes to maintain uniqueness.
    *   **Non-nullability:** Cannot contain null values (for primary keys).
    *   **Stability:** Values should ideally not change over time.

*   **H) Classification of Identifiers**
    *   **Primary Key (PK):** A chosen candidate key to uniquely identify records in a table.
    *   **Candidate Key:** Any attribute or set of attributes that can uniquely identify a tuple (row) in a relation.
    *   **Alternate Key:** A candidate key that is not chosen as the primary key.
    *   **Foreign Key (FK):** An attribute or set of attributes in one table that refers to the primary key in another table, establishing a relationship.

*   **I) Identifier Relationship and Non-identifier Relationship**
    *   **Identifier Relationship (Identifying Relationship):** Occurs when the primary key of the parent entity is included as part of the primary key of the child entity. Typically used for weak entities.
    *   **Non-identifier Relationship (Non-identifying Relationship):** Occurs when the primary key of the parent entity is included as a non-primary key attribute in the child entity.

*   **J) Super-type and Sub-type (Generalization/Specialization)**
    *   **Super-type Entity:** A generic entity type that shares common attributes and relationships (e.g., `Person`).
    *   **Sub-type Entity:** A specialized entity type that inherits attributes from a super-type and has its own unique attributes and relationships (e.g., `Employee`, `Student` derived from `Person`).
    *   Used to model "IS-A" relationships.

#### 07. Connection Trap

*   Situations in ER diagrams that can lead to incorrect or ambiguous query results.
*   **A) Fan Trap:** Occurs when a model represents a one-to-many relationship path through a central entity, causing confusion about which path to follow (e.g., one department has many employees, one employee works on many projects, but which project is associated with which employee in a specific department?). Can be resolved by creating new relationships or views.
*   **B) Chasm Trap:** Occurs when a model suggests a relationship between entities, but the pathway connecting them contains a "missing link" or optional participation that prevents certain entity instances from being connected (e.g., a `Branch` *has* `Employees` (optional) and `Employees` *manage* `Accounts`. If an employee doesn't manage an account, a branch can't "see" an account through that employee). Resolved by ensuring mandatory participation or defining explicit relationships.

#### 08. Object-Relational Mapping (ORM)

*   A programming technique for converting data between incompatible type systems using object-oriented programming languages.
*   Maps objects in code to rows in relational database tables.
*   **A) Class Conversion:**
    *   An object-oriented class typically maps to a database table.
    *   Class attributes map to table columns.
    *   Class instances map to table rows.
*   **B) Conversion of the Class Relation into a Relational Relationship:**
    *   Object relationships (e.g., composition, aggregation, association) are mapped to foreign key relationships in the database.

#### 09. Integrity and Key

*   **A) Integrity (Constraints)**
    *   Rules to ensure data accuracy and consistency within a database.
    *   **Entity Integrity:** No primary key can have a null value (ensures uniqueness and identification).
    *   **Referential Integrity:** Foreign key values must either be null or match an existing primary key value in the referenced table (ensures consistency between related tables).
    *   **Domain Integrity:** All values in a column must conform to the defined data type, format, and range (ensures valid data entries).

*   **B) Key:**
    *   An attribute or set of attributes used to uniquely identify records (primary key), link tables (foreign key), or serve as potential identifiers (candidate key). (See "Classification of Identifiers" above for details).

### V. Normalization and Denormalization

#### 01. Normalization and Anomalies

*   **Normalization:** A systematic process to organize the columns and tables of a relational database to minimize data redundancy and improve data integrity. It divides larger tables into smaller, linked tables.
*   **Anomalies:** Problems that arise from poorly designed databases with redundant data.
    *   **A) Insertion Anomaly:** Cannot insert new data into the database without having data for another entity (e.g., can't add a new department until an employee is assigned to it).
    *   **B) Deletion Anomaly:** Deleting a record unintentionally removes other important, unrelated data (e.g., deleting an employee also deletes the only record of their department).
    *   **C) Update Anomaly:** Changing a value requires updating multiple records, leading to inconsistencies if some are missed (e.g., changing a department name requires updating all employees in that department).

#### 02. Concept of Functional Dependency and Rule of Inference

*   **A) Functional Dependency (FD):** A constraint between two sets of attributes in a relation. If A and B are attributes (or sets of attributes) of a relation, B is functionally dependent on A if each value of A determines exactly one value of B (A → B).
*   **B) Armstrong's Axioms:** A set of inference rules used to derive all functional dependencies in a relational database.
    *   **Reflexivity:** If B ⊆ A, then A → B.
    *   **Augmentation:** If A → B, then AC → BC (where C is any attribute set).
    *   **Transitivity:** If A → B and B → C, then A → C.
    *   (Also Decomposition, Union, Pseudotransitivity, which can be derived from these three).

#### 03. Database Design in Which Normalization is Applied (1st, 2nd, 3rd, Boyce-Codd)

*   **A) Normalization Process (General Steps):**
    1.  Start with an unnormalized table.
    2.  Apply rules for 1NF.
    3.  Apply rules for 2NF.
    4.  Apply rules for 3NF.
    5.  Apply rules for BCNF. (Higher normal forms exist but are less common).
*   **B) Example of Normalization (Conceptual):**
    *   **Unnormalized:** A table `EmployeeProject` with `EmployeeID`, `EmployeeName`, `ProjectID`, `ProjectName`, `ProjectLocation`.
        *   Problem: `ProjectName` and `ProjectLocation` repeat for each employee on a project. `EmployeeName` repeats for each project an employee is on.
    *   **1st Normal Form (1NF):** Eliminate repeating groups. Each column contains atomic (single) values.
        *   Example: If an employee had multiple skills in one cell, separate them into multiple rows or a new table.
    *   **2nd Normal Form (2NF):** Be in 1NF *and* all non-key attributes must be fully functionally dependent on the *entire* primary key. Remove partial dependencies.
        *   Example: If `(EmployeeID, ProjectID)` is PK, but `EmployeeName` depends only on `EmployeeID` (partial dependency). Create `Employee` table (`EmployeeID`, `EmployeeName`) and `Project` table (`ProjectID`, `ProjectName`, `ProjectLocation`). `EmployeeProject` table now has `(EmployeeID, ProjectID)`.
    *   **3rd Normal Form (3NF):** Be in 2NF *and* all non-key attributes must be non-transitively dependent on the primary key. Remove transitive dependencies.
        *   Example: In `Project` table, `ProjectLocation` might depend on `ProjectName` (transitive dependency if `ProjectName` determines `ProjectLocation`). Create `ProjectLocation` table.
    *   **Boyce-Codd Normal Form (BCNF):** A stricter version of 3NF. For every non-trivial functional dependency A → B, A must be a superkey. Deals with cases where 3NF doesn't eliminate all redundancy (e.g., when a non-key attribute determines part of a composite key).

#### 04. Database Design to Which Normalization is Applied - (4th Normal Form - 4NF)

*   **A) Concept of the Fourth Normalization (4NF):** A relation is in 4NF if it is in BCNF and contains no multi-valued dependencies (MVDs).
    *   **Multi-valued Dependency (MVD):** An attribute A is said to be multi-valued dependent on B (B →→ A) if for each value of B, there is a set of zero or more values of A, and this set is independent of other attributes.
*   **B) Characteristics of the Fourth Normalization:** Addresses data redundancy caused by multiple independent multi-valued facts about an entity.
*   **C) Targets of the Fourth Normalization:** Tables with more than one multi-valued attribute that are independent of each other but dependent on the same key.
*   **D) Performing the Fourth Normalization:** Decompose the table into smaller tables, each representing a single multi-valued dependency, keeping the key.

#### 05. Database Design to Which Normalization is Applied - (5th Normal Form - 5NF)

*   **A) Concept of the Fifth Normalization (5NF):** A relation is in 5NF if it is in 4NF and contains no join dependencies.
    *   **Join Dependency (JD):** Occurs when a table can be losslessly decomposed into multiple smaller tables, and then re-joined to produce the original table without spurious tuples (extra rows).
*   **B) Characteristics of the Fifth Normalization:** Addresses cases where a table can be decomposed into smaller tables, even if it is in 4NF, to eliminate remaining redundancy. Often rare in practical database design.
*   **C) Performing the Fifth Normalization:** Decompose a table with a join dependency into smaller tables such that the natural join of these smaller tables produces the original table without any loss of information or creation of spurious information.

#### 06. Denormalization

*   **A) Concept and Procedure of Denormalization:**
    *   **Concept:** The process of intentionally introducing redundancy into a database by combining tables or adding redundant columns, typically to improve query performance.
    *   **Procedure:**
        1.  Identify performance bottlenecks in a normalized schema.
        2.  Analyze frequently used queries.
        3.  Combine tables, add derived columns, or create summary tables.
        4.  Implement and monitor performance.
*   **B) Actual Denormalization (Common Techniques):**
    *   **Adding Derived Columns:** Storing calculated values (e.g., `TotalOrderAmount`) rather than calculating on the fly.
    *   **Combining Tables:** Merging two related tables into one to avoid joins for frequent queries.
    *   **Duplicating Columns:** Copying a column from a parent table into a child table to avoid a join (e.g., `CustomerName` in `Order` table).
    *   **Creating Summary/Aggregate Tables:** Pre-calculating and storing aggregate data (e.g., daily sales totals).

#### 07. Considerations for Performance Design

*   Choose appropriate data types.
*   Create indexes strategically.
*   Optimize queries.
*   Consider denormalization for read-heavy operations.
*   Partition large tables.
*   Manage transaction concurrency.
*   Hardware scaling (CPU, RAM, I/O).

### VI. Physical Design

#### 01. Relational Table Conversion and Table Design

*   **A) Differences between Academic World's and Industry's Understanding of Physical Modeling:**
    *   **Academic:** Focuses on theoretical purity, strict adherence to normal forms.
    *   **Industry:** Balances theoretical ideals with practical performance requirements, often using denormalization and specific DBMS features.
*   **B) Relational Table Conversion:**
    *   Converting the logical data model (ER Diagram) into a physical model (set of tables, columns, data types, indexes, and constraints).
    *   Each entity becomes a table. Attributes become columns. Relationships become foreign keys.
*   **C) Table Design:**
    *   Choose meaningful table and column names.
    *   Define primary and foreign keys correctly.
    *   Select appropriate data types for each column.
    *   Consider nullability constraints.
    *   Partitioning for very large tables.

#### 02. Data Type Design

*   Selecting the most appropriate data type for each column affects storage, performance, and data integrity.
*   **A) Character Data Type:**
    *   `CHAR(n)`: Fixed-length string (padded with spaces).
    *   `VARCHAR(n)`: Variable-length string (stores only actual characters).
    *   `TEXT`/`LOB`: For very long character strings or large objects.
*   **B) Numeric Data Type:**
    *   `INT`/`INTEGER`: Whole numbers.
    *   `DECIMAL(p,s)`/`NUMERIC`: Exact decimal numbers (for monetary values).
    *   `FLOAT`/`REAL`/`DOUBLE`: Approximate floating-point numbers.
*   **C) Binary Data Type:**
    *   `BLOB` (Binary Large Object): For storing raw binary data (images, audio, video).
*   **D) Date Data Type:**
    *   `DATE`: Stores date only (YYYY-MM-DD).
    *   `TIME`: Stores time only (HH:MI:SS).
    *   `DATETIME`/`TIMESTAMP`: Stores both date and time.

#### 03. Index Design

*   **A) Functions of the Index:**
    *   Speed up data retrieval operations (SELECT queries).
    *   Enforce uniqueness for primary and unique keys.
    *   Improve sorting performance.
*   **B) Index Design Procedure:**
    1.  Identify frequently queried columns (especially in `WHERE`, `JOIN`, `ORDER BY` clauses).
    2.  Create indexes on primary keys and foreign keys automatically or manually.
    3.  Avoid excessive indexing (adds overhead to `INSERT`, `UPDATE`, `DELETE`).
    4.  Monitor index usage and performance.
*   **C) Types of Index Structures:**
    *   **B-Tree Index:** Most common, efficient for range queries and equality lookups.
    *   **Hash Index:** Good for equality lookups, less effective for range queries.
    *   **Clustered Index:** Stores the actual data rows in the physical order of the index key. A table can only have one.
    *   **Non-Clustered Index:** Stores pointers to the actual data rows, which are stored elsewhere.

#### 04. View Design

*   **A) Characteristics of the Database View:**
    *   A virtual table based on the result-set of a SQL query.
    *   Does not store data itself; its content is generated dynamically when queried.
    *   Provides data security (restrict access to specific rows/columns).
    *   Simplifies complex queries.
    *   Can customize presentation of data.
*   **B) Creation of the View:**
    *   Using the `CREATE VIEW` statement: `CREATE VIEW view_name AS SELECT column1, column2 FROM table_name WHERE condition;`
*   **C) Modifying Data with a View:**
    *   Some views are "updatable" (allow `INSERT`, `UPDATE`, `DELETE` operations on the underlying table), but many are not (e.g., views with joins, aggregate functions, or derived columns).
*   **D) Other Considerations:**
    *   Can introduce performance overhead if the underlying query is complex.
    *   Careful design is needed to avoid ambiguity or unexpected behavior.

#### 05. Distributed Database

*   **A) Characteristics of the Distributed Database:**
    *   A database where storage devices are not all attached to a common processing unit.
    *   Data is stored on multiple computers (nodes) located across a network.
    *   Appears as a single logical database to users.
    *   Offers high availability, scalability, and local autonomy.
*   **B) Data Transparency:** The extent to which the distributed nature of the database is hidden from the user.
    *   **Location Transparency:** Users don't need to know where the data is physically stored.
    *   **Replication Transparency:** Users don't need to know if data is duplicated across multiple sites.
    *   **Fragmentation Transparency:** Users don't need to know if a table is divided into fragments across different sites.

### VII. Database Quality and Standardization

#### 01. Data Quality Control Framework

*   A system to ensure data meets certain standards of excellence.
*   **A) Data Value:** Focuses on the characteristics of the data itself.
    *   **Accuracy:** Data is correct and reflects reality.
    *   **Completeness:** All required data is present.
    *   **Consistency:** Data values are uniform across systems and time.
    *   **Timeliness:** Data is available when needed and up-to-date.
    *   **Validity:** Data conforms to defined formats, ranges, and rules.
*   **B) Data Structure:** How data is organized and modeled.
    *   Ensuring appropriate data types, relationships, and constraints.
*   **C) Data Management Process:** The procedures for collecting, storing, processing, and disseminating data.
    *   Defining clear roles, responsibilities, and workflows for data handling.
*   **D) Data Quality Management Maturity Model:** A framework to assess and improve an organization's data quality capabilities over time, typically moving through stages like initial, repeatable, defined, managed, and optimizing.

#### 02. Data Standardization

*   **A) Overview of Data Standardization:** The process of establishing uniform definitions, formats, and rules for data elements across an organization or system.
*   **B) Necessity of Data Standardization:**
    *   Improves data quality and consistency.
    *   Facilitates data integration and sharing.
    *   Reduces errors and rework.
    *   Enhances decision-making.
    *   Supports regulatory compliance.
*   **C) Components of Data Standardization:**
    *   **Data Naming Standards:** Consistent conventions for naming tables, columns, and other objects.
    *   **Data Definition Standards:** Clear, unambiguous descriptions of data elements.
    *   **Data Domain Standards:** Defining allowable values or ranges for attributes.
    *   **Data Format Standards:** Specifying the structure of data (e.g., date formats).
*   **D) Defining Data Standards:** Involves identifying critical data elements, researching best practices, documenting standards, and getting stakeholder consensus.
*   **E) Confirming Data Standards:** Involves validating that defined standards are being applied and are effective through auditing and quality checks.

### VIII. Relational Operation (Relational Algebra)

#### 01. Understanding the Concept of Relational Algebra

*   A procedural query language used to manipulate relations (tables).
*   Provides a theoretical foundation for relational databases and SQL.
*   Operations take one or two relations as input and produce a new relation as output.

#### 02. Set Operation and Relation Operation

*   **A) Set Operation (from set theory):**
    *   **Union (∪):** Combines rows from two compatible relations (removes duplicates).
    *   **Intersection (∩):** Returns rows that appear in both compatible relations.
    *   **Difference (-):** Returns rows in the first relation that are not in the second compatible relation.
    *   **Cartesian Product (x):** Combines every row from the first relation with every row from the second relation.
*   **B) Relation Operation (unique to relational algebra):**
    *   **Select (σ):** Filters rows (tuples) based on a specified condition (subset of rows).
    *   **Project (π):** Filters columns (attributes) by keeping only the specified ones (subset of columns).
    *   **Join (⋈):** Combines two relations based on a common attribute or condition (most common is `Natural Join` which joins on common attributes with matching values).
    *   **Divide (÷):** Used for queries involving "for all" or "contains all" (e.g., "find students who took all courses offered by the CS department").

#### 03. Extended Relational Algebra Operations

*   **Outer Join:** Includes all rows from one or both tables, even if there's no match in the other. (Left Outer Join, Right Outer Join, Full Outer Join).
*   **Aggregate Functions:** `SUM`, `AVG`, `COUNT`, `MIN`, `MAX` (often combined with Group By).
*   **Assignment (←):** Assigns the result of an expression to a temporary relation.

### IX. Relational Database Language (SQL)

#### 01. Types of Relational Database Languages

*   SQL (Structured Query Language) is the standard language for managing relational databases. It's broadly categorized into:
    *   **Data Definition Language (DDL):** For defining and modifying database schema.
    *   **Data Control Language (DCL):** For managing permissions and access control.
    *   **Data Manipulation Language (DML):** For querying and modifying data within the database.

*   **B) Changes in SQL and the Characteristics of SQL3:**
    *   SQL has evolved through various standards (SQL-86, SQL-89, SQL-92, SQL:1999/SQL3, SQL:2003, etc.).
    *   **SQL3 (SQL:1999):** Introduced significant enhancements, including:
        *   Object-relational features (e.g., user-defined types, row types, reference types).
        *   Recursive queries (e.g., `WITH RECURSIVE`).
        *   Triggers.
        *   Enhanced large object types (CLOB, BLOB).
        *   Standardization of OLAP functions.

#### 02. Data Definition Language (DDL)

*   Used to create, modify, and delete database objects (tables, indexes, views, schemas).
*   **A) Types of Data Definition Language Commands:**
    *   `CREATE`: To create database objects (e.g., `CREATE TABLE`, `CREATE INDEX`, `CREATE VIEW`).
    *   `ALTER`: To modify the structure of existing database objects (e.g., `ALTER TABLE ADD COLUMN`).
    *   `DROP`: To delete database objects (e.g., `DROP TABLE`, `DROP VIEW`).
    *   `TRUNCATE`: To remove all records from a table quickly, resetting auto-increment counters (faster than `DELETE` without a `WHERE` clause).
    *   `RENAME`: To rename a database object.

#### 03. Data Control Language (DCL)

*   Used to manage user access and permissions to the database.
*   **A) Roles of the Data Control Language:**
    *   Control who can access what data.
    *   Ensure data security and privacy.
    *   Grant or revoke specific privileges.
*   **B) Types of Data Control Language Commands:**
    *   `GRANT`: To give users specific permissions on database objects (e.g., `GRANT SELECT ON Employees TO user1`).
    *   `REVOKE`: To remove previously granted permissions (e.g., `REVOKE DELETE ON Orders FROM user2`).

#### 04. Data Manipulation Language (DML)

*   Used for querying and modifying data within the database tables.
*   **A) Basic DML Operations:**
    *   `SELECT`: To retrieve data from one or more tables.
    *   `INSERT`: To add new rows of data into a table.
    *   `UPDATE`: To modify existing data in a table.
    *   `DELETE`: To remove rows of data from a table.
*   **B) Aggregate DML Operations:**
    *   Functions that perform calculations on a set of rows and return a single value.
    *   `COUNT()`: Number of rows.
    *   `SUM()`: Sum of values in a numeric column.
    *   `AVG()`: Average of values in a numeric column.
    *   `MIN()`: Smallest value in a column.
    *   `MAX()`: Largest value in a column.
    *   Often used with `GROUP BY` clause.
*   **C) Advanced DML Join Operations:**
    *   Used to combine rows from two or more tables based on a related column between them.
    *   `INNER JOIN`: Returns rows when there is at least one match in both tables.
    *   `LEFT (OUTER) JOIN`: Returns all rows from the left table, and the matching rows from the right table. If no match, NULLs for right table columns.
    *   `RIGHT (OUTER) JOIN`: Returns all rows from the right table, and the matching rows from the left table. If no match, NULLs for left table columns.
    *   `FULL (OUTER) JOIN`: Returns all rows when there is a match in one of the tables. Returns rows from both tables even if no match in other.
    *   `CROSS JOIN`: Returns the Cartesian product of the two tables (like `FROM table1, table2` without a `WHERE` clause).
    *   `SELF JOIN`: A table joined with itself, using aliases.

### X. Database Query Application

#### 01. Stored Procedure

*   **A) Definition of the Stored Procedure:**
    *   A pre-compiled collection of one or more SQL statements (and control-of-flow statements) stored in the database.
    *   Executes as a single unit, invoked by name.
*   **B) Strengths and Weaknesses of the Stored Procedure:**
    *   **Strengths:**
        *   **Performance:** Pre-compiled, reducing parsing/optimization time.
        *   **Reduced Network Traffic:** Multiple SQL statements executed with a single call.
        *   **Security:** Users can be granted permission to execute procedures without direct access to underlying tables.
        *   **Modularity & Reusability:** Code can be written once and called multiple times.
        *   **Data Integrity:** Can enforce complex business rules consistently.
    *   **Weaknesses:**
        *   **Portability Issues:** Syntax can vary significantly between different database systems.
        *   **Debugging Challenges:** More complex to debug than simple SQL queries.
        *   **Resource Consumption:** Can consume significant server resources if poorly written.
        *   **Version Control:** Managing changes to procedures can be tricky.

#### 02. Embedded SQL

*   **A) Definition of Embedded SQL:**
    *   SQL statements written directly within a host programming language (e.g., C, Java, Python).
    *   Requires a precompiler or library to translate SQL statements into host language API calls.
*   **B) Characteristics of Embedded SQL:**
    *   Combines the power of SQL with the procedural capabilities of a host language.
    *   Tight integration with application logic.
    *   Static SQL: SQL statements are fixed at compile time.
*   **C) Embedded SQL Cursor:**
    *   Used to process the results of a `SELECT` statement that returns multiple rows, one row at a time.
    *   Allows an application to fetch, process, and update individual rows from a result set.
    *   Operations: `DECLARE CURSOR`, `OPEN CURSOR`, `FETCH`, `CLOSE CURSOR`.

#### 03. Dynamic SQL

*   **Definition of Dynamic SQL:**
    *   SQL statements constructed and executed at runtime (during program execution).
    *   Allows for flexible queries where conditions, table names, or column names might not be known until the application runs.
    *   Often used for building ad-hoc query tools or generic data access components.
    *   Higher risk of SQL injection if inputs are not properly sanitized.

---

================================================================================
ORIGINAL TEXT (First 5000 chars)
================================================================================

--- Page 10 ---
A) Entity, attribute,  identifier 58
B) Characteristics  of the entity 58
C) Classification  of entities 58
D) Classification  of attributes 59
E) Relationshio 59
F) How to read relationships 60
G) Characteristic  of the identifier 60
H) Classification  of identifiers 61
|) Identifier  relationship  and non-identifier  relationship 61
J) Super—type  and sub-type 62
07 Connection  Trap 63
A) Fan trap 63
B) Chasm trap 64
08 Object-Relational  Mapping  (ORM) 64
A) Class conversion 64
B) Conversion  of the class relation into a relational  relationshio 65
09 Integrity  and Key 65
A) ntegrity 65
B) Key 66
V. Normalization  and Denormalization 67
01 Normalization  and Anomalies 69
A) Insertion  anomaly 69
M2 Database  9


--- Page 11 ---
ESSENCE
B) Deletion  anomaly
C) Update  anomaly
02 Concept  of Functional  Dependency  and Rule of Inference
A) Functional  dependency
B) Armstrong's  axioms
03 Database  Design in Which Normalization  is Applied  (1st, 2nd, 3rd, Boyce-Codd)
A) Normalization  process  ([Figure  28))
B) Example  of normalization
04 Database  Design in Which Normalization  is Applied  - (4th normailzation)
A) Concept  of the fourth normalization
B) Characteristics  of the fourth normalization
C) Targets  of the fourth normalization
D) Performing  the fourth normalization
05 Database  Design to Which Normalization  is Applied  - (Sthnormalization)
A) Concept  of the fifth normalization
B) Characteristics  of the fifth normalization
C) Performing  the fifth normalization
D)Performing  the fifth normalization
06 Denormalization
A) Concept  and procedure  of denormalization
B) Actual denormalization
07 Considerations:  for Performance  Design
10 TOPCIT  ESSENCE69
69
70
70
“
71
71
a
73
13
73
14
1S
76
16
76
76
77
78
82


--- Page 12 ---
01 Relational  Table Conversion  and Table Design 86
A) Differences  between  the academic  world's and industry's  understanding  of
physical  modeling 86
B) Relational  table conversion 86
C) Table design 87
02 Data Type Design 88
A) Character  data type 88
B) Numeric  data type 88
C) Binary data type 88
D) Date data type 88
03 Index Design 89
A) Functions  of the index 89
B) Index design procedure 89
C) Types of index structures 89
04 View Design 89
A) Characteristics  of the database  view 89
B) Creation  of the view 90
C) Modifying  data with a view 90
D) Other considerations 90
05 Distributed  Database 91
A) Characteristics  of the distriouted  database m1
B) Data transparency 91
M2 Database  11


--- Page 13 ---
VII. Database  Quality  and Standardization 93
01 Data Quality  Control  Framework 95
A) Data value 95
B) Data structure 96
C)Data management  process 96
D) Data quality management  maturity  model 96
02 Data Standardization 97
A) Overview  of data standardization 97
B) Necessity  of data standardization 97
C) Components  of data standardization 98
D) Defining  data standards 98
E) Confirming  data standards 99
VIII. Relational  Operation  (relational  algebra) 100
01 Understanding  the Concept  of Relational  Algebra 101
02 Set Operation  and Relation  Operation 101
A) Set operation 101
B) Relation  operation 101
03 Extended  Relational  Algebra  Operations 102
IX, Relational  Database  Language  (SQL) 103
01 Types of Relational  Database  Languages 105
12 TOPCIT  ESSENCE


--- Page 14 ---
B) Changes  in SQL and the characteristics  of SQL3 105
02 Data Definition  Language  (DDL) 106
A) Types of data definition  language 106
03 Data Control  Language  (DCL) 107
A) Roles of the data control language 107
B) Types of data control languages 107
04 Data Manipulation  Language  (DML) 108
A) Basic DML operations 108
B) Aggregate  DML operations 108
C) Advanced  DML join operations 109
X. Database  Query  Application 111
01 Stored Procedure 113
A) Definition  of the stored procedure 113
B) Strengths  and weaknesses  of the stored procedure 113
C) Strengths  of the stored procedure 113
D) Shortcomings  of the stored procedure 113
02 Embedded  SQL 113
A) Definition  of embedded  SQL 113
B) Characteristics  of embedded  SQL 113
C) Embedded  SQL cursor 114
03 Dynamic  SQL 115
M2 Database  13


