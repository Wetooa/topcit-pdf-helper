LEARNING GUIDE: Pages 37-41
Generated: 2025-12-05 14:20:28
PDF: 1 - Software Development OCR

================================================================================
LEARNING GUIDE
================================================================================

Here is a simplified, easy-to-read learning guide based on the provided text:

---

# Software Development Essentials: Reverse Engineering, Data Structures & Algorithms

## 1. Reverse Engineering

### 1.1 Definition
*   **Reverse Engineering:** The process of analyzing a finished product (software, system, document) to understand its design, structure, and functionality. It creates design information from an existing program or document.
*   **Opposite of Forward Engineering:** Where development proceeds sequentially from design to product.

### 1.2 Input and Output
*   **Input:** Source code, object code, work procedures, libraries, etc.
*   **Output:** Structure diagrams, data flow charts, control flow graphs, entity-relationship diagrams, etc.

### 1.3 Why Reverse Engineering is Necessary
*   Difficulty maintaining existing systems.
*   System efficiency decreases due to frequent changes.
*   Redeveloping business systems (e.g., file system to relational database).
*   Downsizing mainframe systems.

### 1.4 Advantages
*   Analyze commercialized or previously developed software.
*   Improve maintainability by analyzing existing system data and information at the design level.
*   Facilitates Computer-Aided Software Engineering (CASE) by storing system information in a repository.

### 1.5 Types of Reverse Engineering
*   **Logic Reverse Engineering:** Extracts information from source code and stores it as physical design information.
*   **Data Reverse Engineering:** Modifies existing databases or migrates them to new database management systems.

---

## 2. Data Structures and Algorithms

### 2.1 Introduction & Importance

*   **Learning Objectives:**
    *   Understand data structure definitions, classifications (linear/nonlinear), and their usage.
    *   Understand algorithms, analyze their performance, and select appropriate ones.
*   **Core Concepts:** Array, list, stack, queue, deque, tree, graph; Algorithm definition, performance analysis, sorting/searching.
*   **Real-world Impact:** Errors in understanding basic software technologies like data structures and algorithms can lead to critical system failures (e.g., the 2003 US blackout caused by a "race condition" error due to incorrect data structure handling).
*   **Definition of a Data Structure:** A way of organizing and storing data in a computer's memory, allowing for efficient access and modification.
*   **Definition of an Algorithm:** A well-defined computational process that takes input values, performs calculations, and produces output values to solve a problem.
*   **Why they matter:** Selecting the correct data structure and algorithm is crucial for developing high-quality, efficient software that is optimal for a given environment, considering coding efficiency, processing time, and storage.

---

## 3. Data Structure Details

### 3.1 Definition
*   A method for storing data in a computer's memory systematically, enabling efficient expression and utilization based on data characteristics and usage.

### 3.2 Classification

*   **Linear Structure:**
    *   **Description:** Data elements are arranged in a straight line, connected in sequence, with a one-to-one relationship between adjacent elements (before/after).
    *   **Examples:** Array, Linear List, Linked List, Stack, Queue, Dequeue.

*   **Non-linear Structure:**
    *   **Description:** Data elements have special forms, such as hierarchical structures, where one data element can be related to multiple others (one-to-many or many-to-many relationships).
    *   **Examples:** Tree, Graph.

### 3.3 Comparison: Sequential vs. Linked Data Structures

| Feature                     | Sequential Data Structure       | Linked Data Structure                                   |
| :-------------------------- | :------------------------------ | :------------------------------------------------------ |
| **Memory Storage**          | Data stored consecutively.      | Data stored anywhere; logical sequence expressed by links. |
| **Logical/Physical Sequence** | Match (data order = memory order). | Do not match (logical order ≠ memory order).             |
| **Insert/Delete Operations** | Physical sequence changes.      | Only link information changes; physical sequence often unchanged. |
| **Implementation Technique** | Uses an array.                  | Uses pointers.                                          |

### 3.4 Stack

*   **Definition:** A linear data structure where data is added and removed only from one end, called the "top." It follows the **LIFO** (Last-In-First-Out) principle.
    *   The last element inserted is the first one to be removed.
*   **Conceptual Diagram:** Imagine a stack of plates – you add plates to the top, and remove plates from the top.
*   **Key Operations:**
    *   `top()`: Returns the data value at the top of the stack without removing it.
    *   `push()`: Inserts data onto the top of the stack.
    *   `pop()`: Deletes and returns data from the top of the stack.
    *   `isempty()`: Returns `true` if the stack has no elements, `false` otherwise.
    *   `isfull()`: Returns `true` if the stack is full, `false` otherwise (often for fixed-size stacks).

### 3.5 Queue

*   **Definition:** A linear data structure where data is inserted at one end (the "rear" or "bottom") and deleted from the other end (the "front" or "top"). It follows the **FIFO** (First-In-First-Out) principle.
    *   The first element inserted is the first one to be removed.
*   **Conceptual Diagram:** Imagine a line of people – the first person in line is the first one to be served, and new people join at the end of the line.
*   **Key Operations (Common, not explicitly listed for queue in text but implied by stack ops):**
    *   `enqueue()`: Inserts data at the rear of the queue.
    *   `dequeue()`: Deletes and returns data from the front of the queue.
    *   `front()`: Returns the data value at the front of the queue without removing it.
    *   `isempty()`: Returns `true` if the queue has no elements, `false` otherwise.
    *   `isfull()`: Returns `true` if the queue is full, `false` otherwise.

---

================================================================================
ORIGINAL TEXT (First 5000 chars)
================================================================================

--- Page 37 ---
ESSENCE
in the initial lifecycle  phase is created,  using the program  or document  obtained  in the last phase of the software  lifecycle.
Reverse  engineering  is the opposite  concept  of forward  engineering  in which development  is performed  sequentially  from the
design. The concept  of reverse  engineering  can be understood  by looking  at the flow of input and output  below.
<Table  6> Input/output  of reverse  engineering
Input Output
Data or document  in the form of I/O, such as the source code, | Structure  diagram,  data flow chart, control flow graph, entity
object  code, work procedure,  library, etc. relationship  diagram,  etc.
B) The main reasons  why reverse  engineering  is necessary
+ When it is difficult  to maintain  a running  system.
+ When frequent  changes  decrease  a system’s  efficiency
+ When redeveloping  a business  system based on a file system into one based on a relational  database.
+ When downsizing  the default  mainframe
C) Advantages  of reverse  engineering
+ Commercialized  or previously  developed  software  can be analyzed.
+ Maintainability  can be improved  since the data and information  of the existing  system  can be analyzed  at the
design level.
+ CASE can be used easily by storing  existing  system information  in a repository.
D) Types of reverse  engineering
+ Reverse engineering  can be divided into logical reverse engineering  and data reverse engineering  for
description.
<Table  7> Types of reverse  engineering
Type Description
Logic reverse Information  is extracted  from the source code and stored in the physical  design information  storage.
engineering Physical  design information  is obtained
Data reverse
engineeringThe existing  database  is modified  or migrated  to a new database  management  system.
36 TOPCIT  ESSENCE


--- Page 38 ---
lll. Data Structure  and Algorithm
>> Learning  objectives
1. To be able to explain the definition  and classification  of the data structure  and use the linear/
nonlinear  structure.
2. To be able to understand  the role of the algorithm and select an appropriate  algorithm  depending
on the situation.
- Array, list, stack, queue, deque, tree, graph
- Algorithm  definition,  algorithm  performance  analysis,  sorting/searching  algorithm
M1 Software  development  37


--- Page 39 ---
ESSENCE
+ Preview  for practical  business
In 2003, a massive  blackout  occurred  in the northeastern  United States, plunging  seven states in
the US. and one province  in Canada into darkness.  When the incident  was investigated,  it was found
that the power outage had been caused by a software  error in the XA/21 system, which occurs in
the multi-process  method.  That is, the “race condition’  (a type of deadlock)  caused the blackout.
The error occurred  because  two programs  in the XA/21 system simultaneously  wrote and accessed
the same data structure.  The error corrupted  the data structure,  which in turn put the alarm process
into an infinite loop, and even an alarm processing  failure was not notified.  The alarm queue increased
indefinitely,  and all available  memory  was consumed  after 30 minutes.  At that time, the main server
was down. A failover  mechanism  was activated,  and the backup server became  the main server.
However,  the backup server  also failed because  it couldn't  handle the infinitely increasing  queue.
This incident  is a representative  case of software  causing  a fatal error resulting  in tremendous
damage  to real life, because  the software  was developed  without  a proper understanding  of basic
software  technologies  such as the data structure  and algorithm.
A data structure,  which is a way of structurally  expressing  data in programming,  presents  a way to
conveniently  access data and store or organize  them for the purpose  of changing  the data structure.
An algorithm  refers to a well-defined  calculation  process  to output after solving  the problem  by
receiving  a certain  value.
For example,  let’s consider  a case in which a house is built with blocks. We can build the best house
only when we select and stack the most appropriate  block for a given design, such as material,  color,
and shape among several blocks, depending  on the structure  or shape of the house. However,  what is
far more important  than this is that we have to properly  understand  the materials  and characteristics
of each block and the various utilization  methods.  If we don’t use the blocks in the right place, a
shoddy and faulty construction  is inevitable  when the house is completed. The data structure  and
algorithm  are like these blocks. Various  basic technologies  are available  that keep pace with the rapid
development  of information  systems.  Therefore,  we can expect high-quality  software  that is optimal
for a given environment,  if we develop  software  by adopting  and applying  the most appropriate  data
structure  and algorithm.
The data structure is an...
