LEARNING GUIDE: Pages 43-47
Generated: 2025-12-05 14:21:01
PDF: 1 - Software Development OCR

================================================================================
LEARNING GUIDE
================================================================================

Here's a simplified, easy-to-read learning guide based on the provided text:

---

# Data Structures & Algorithms Learning Guide

## 1. Graphs

### 1.1 What is a Graph?
*   A **Graph** is a data structure representing **many-to-many relationships** between connected elements.
*   It consists of:
    *   **Vertices (nodes):** Represent objects.
    *   **Edges:** Connect these objects.
*   **Purpose:** Solves complex problems like electric circuit analysis, shortest path search, and AI.

### 1.2 Types of Graphs
*   **Undirected Graph:** Edges are lines without direction (A to B is the same as B to A).
*   **Directed Graph:** Edges have a specific direction, meaning the sequence of vertices in a connection matters (A to B is different from B to A).
*   **Complete Graph:** Every vertex is connected to every other vertex, having the maximum possible number of edges.
*   **Weighted Graph:** Edges have an assigned numerical value (weight), often representing cost, distance, or time.

### 1.3 How Graphs are Stored in Memory
Graphs are stored using different methods depending on their use:

*   **Adjacency Matrix:**
    *   Uses a **two-dimensional array** (matrix).
    *   `matrix[i][j]` indicates if an edge exists between vertex `i` and vertex `j`.
    *   Suitable for dense graphs (many edges).
*   **Adjacency List:**
    *   Uses a **linked data structure**.
    *   For each vertex, a list stores its adjacent vertices.
    *   Each vertex has a linked list of its neighbors.
    *   Suitable for sparse graphs (few edges).

## 2. Data Structure Selection & Utilization

### 2.1 Criteria for Selecting a Data Structure
Choose a data structure based on:
*   Data processing time requirements
*   Size of the data
*   Frequency of data utilization (reads)
*   Frequency of data updates (writes)
*   Ease of programming with the structure

### 2.2 Common Uses of Data Structures
*   **List (Array, Linked List):** DBMS indexes, general search/sorting problems.
*   **Stack (LIFO):** Interrupt handling, recursive program control, saving return addresses for subroutines, calculating postfix expressions, "undo" functions in editors.
*   **Queue (FIFO):** Operating system job scheduling, asynchronous data exchange (file I/O, pipes, sockets), keyboard buffers, spool operations.
*   **Deque (Double-Ended Queue):** Combines features of stack and queue, used in areas related to both.
*   **Tree:** Search and sorting, grammar parsing, Huffman coding, decision trees, game AI.
*   **Graph:** Computer networks (Internet, Web), electric circuit analysis, representing binary relations, solving simultaneous equations.

## 3. Algorithms

### 3.1 What is an Algorithm?
*   An **Algorithm** is a step-by-step description of procedures used to solve a specific problem.
*   It's not just about getting a result, but about finding an **efficient method** in terms of processing time and memory use.

### 3.2 Key Conditions for an Algorithm
An algorithm must satisfy the following:
*   **Input:** Must accept one or more data inputs.
*   **Output:** Must produce one or more results.
*   **Definiteness:** Each step must be clearly and unambiguously specified.
*   **Finiteness:** Must terminate after a finite number of steps.
*   **Effectiveness:** Each instruction must be basic enough to be implementable.

### 3.3 Algorithm Analysis Criteria
When evaluating an algorithm, consider:
*   **Correctness:** Produces the right result for valid input within a finite time.
*   **Amount of Work Done:** The number of core operations performed (excluding default or general operations).
*   **Amount of Space Used:** The amount of computer memory required during execution.
*   **Optimality:** Is the algorithm the most appropriate given the system's usage environment (e.g., execution time, memory usage)?
*   **Simplicity:** Is the algorithm clear and easy to understand? Simple algorithms are easier to prove correct and debug.

### 3.4 How to Express an Algorithm
Algorithms can be described in various ways:
*   **Description Language:** Using everyday words or text.
*   **Flow Chart / NS Chart:** Using graphical symbols to represent steps and flow.
*   **Pseudocode:** A simplified, programming-language-like text that's more structured than natural language but less formal than actual code.

### 3.5 Algorithm Performance Analysis (Complexity)
Performance is analyzed by estimating:

*   **Space Complexity:**
    *   The total memory an algorithm needs to execute.
    *   Calculated as: **Fixed Space + Variable Space**
        *   **Fixed Space:** Memory needed permanently (program code, variables, constants), regardless of input size.
        *   **Variable Space:** Memory for data and variables used during execution, which can change with input size.

*   **Time Complexity:**
    *   The total time an algorithm takes to execute.
    *   Calculated as: **Compilation Time + Execution Time**
        *   **Compilation Time:** Fixed time, not dependent on program characteristics.
        *   **Execution Time:** The primary measure, estimated by counting the number of command executions (not actual clock time, which varies by hardware).
    *   **Big O Notation (O(n)):** Used to express execution time, focusing on how runtime grows with input size 'n'.
        *   When comparing algorithms, always choose the one with the smallest Big O value (most efficient).

### 3.6 Common Big O Notations (Algorithm Complexity)
These describe how an algorithm's runtime or space requirements scale with input size (N):

*   **O(1) - Constant:** The solution time is constant, regardless of the input size (e.g., accessing an array element by index).
*   **O(log N) - Logarithmic:** Divides the input data and processes only a portion (e.g., binary search).
*   **O(N) - Linear:** Processes all input data one by one; time grows directly with N (e.g., iterating through a list).
*   **O(N log N) - Linearithmic:** Processes data by dividing and merging (e.g., Merge Sort, Quick Sort).
*   **O(N^2) - Quadratic:** Often involves nested loops, where for each element, it processes all other elements (e.g., Bubble Sort, Selection Sort).
*   **O(N^3) - Cubic:** Similar to quadratic but with three nested loops.
*   **O(2^N) - Exponential:** Processes by testing all possible solutions; very slow for larger N (e.g., solving the Traveling Salesperson Problem brute-force).

## 4. Sorting Algorithms

### 4.1 Classification of Sorting
Sorting methods are chosen based on system characteristics, data amount/state, memory, and execution time.

*   **Internal Sorting:**
    *   Sorts a small quantity of data entirely within the computer's **main memory**.
    *   **Fast** speed.
    *   **Limited** by main memory capacity.
*   **External Sorting:**
    *   Sorts a large volume of data using an **auxiliary storage device** (like a hard drive).
    *   Data is divided into smaller "sub-files," sorted, and then merged.
    *   **Slow** speed.

### 4.2 Types of Internal Sorting Algorithms
Common internal sorting algorithms include:
*   Insertion Sort
*   Shell Sort
*   Selection Sort
*   Quick Sort
*   Bubble Sort
*   Merge Sort
*   Heap Sort
*   Counting Sort
*   Radix Sort
*   Bucket Sort

---

================================================================================
ORIGINAL TEXT (First 5000 chars)
================================================================================

--- Page 43 ---
ESSENCE
@ Graph
A graph is data structure  that expresses  the many-to-many  relationship  between  the connected  elements,  and
is a set of vertices  that represent  objects and the edges that connect  those objects. Graph data structures
often solve problems  based on graph theory by expressing  several complex  problems  on a graph, such as
electric  circuit analysis,  shortest  distance  search, artificial  intelligence,  etc.
<Table 11> Types of graphs
Type Description
Undirected  | A graph that is connected  by undirected  lines between  the
graph vertices of the graph.
Directed A graph whose connection  lines are directional,  where the
graph sequence  of vertices  expressed  in pairs is important. =)v©)
[N;| Complete  | A graph that has as many edges as possible  by connecting
graph all the vertices  with each other on the graph./tNh
Weighted  | A graph in which a weighted  value is assigned  to the edges
graph that pass through  the vertices  of the graph.
The graph is expressed  in memory  using various  graphing  methods  depending  on the function being performed
or method  of application.
+ Adjacency matrix: A method of graphing  using a sequential  data structure.  The presence  of the edge
connecting  two vertices  of the graph as a matrix is stored in a matrix by using a two-dimensional array for
the matrix.
+ Adjacency  List: A graphing  method  using a linked data structure.  Nodes are connected  as many times as the
sequence  number  of each vertex using a simple linked list created by connecting  adjacent  vertices  for each
vertex.
A ; . : Head  of vertex A e-|—> B | e}—>| C | NULLCO9)  B} 1 0 1 Head  of vertex B e+  >{ A | et—>[ C | NULL
c} 1 1 0 | [Head  of vertex  C e+] A | et—>{B  | NULL
[Adjacent  matrix] [Adjacent  list]
[Figure 5] Graphing  method
42 TOPCIT  ESSENCE


--- Page 44 ---
Software  Development )
E) Data structure  selection  criteria
@Data processing  time
@Data size
@Data utilization  frequency
@Data update frequency
Ease  of programming
F) Utilization  of data structures
Data structures  are mainly used in data sorting, search, file organization,  and index. The utilization  fields by data
structure  can be summarized  as follows.
@ List: Array implementation,  DBMS index, problems  such as search or sorting,  etc.
@ Stack: Interrupt  handling,  sequence  control of the recursive  program,  saving the retum address  of the subroutine,
calculating  an expression  represented  in postfix  notation,  undo function  of the text editor, etc.
@® Queue: Job scheduling  of the operating  system,  queue processing,  asynchronous  data exchange  (file I/O, pipes,
sockets),  keyboard  buffer use, spool operation,  etc.
@ Deque: A data structure  that makes the most of the strengths  of the stack and queue only, and which is mostly
used in the fields related  to the stack and queue.
© Tree: Problems  like search and sorting,  grammar  parsing,  Huffman  code, decision  trees, games,  etc.
© Graph: Computer  network  (local area network,  internet,  web, etc.), electric circuit analysis,  binary relation,
simultaneous  equations,  etc.
02 Algorithm
A) Algorithm  overview
@ Algorithm  definition
An algorithm  is a description  of a series of processing  procedures  used to solve a given problem  by stages.  It is
a specification  that logically  describes  a step-wise  procedure  by abstracting  the problem-solving  method.  The
algorithm  is not designed simply to obtain the desired result, but also to develop  an efficient  method in terms
of processing  time and storage  space use.
@ Conditions  of algorithms
<Table 12> Conditions  of algorithms
Condition Description
Input More than one data that are needed  to execute  an algorithm  should be entered  from outside.
Output More than one result should be output after executing  an algorithm.
7 Instructions  for each processing  step of the algorithm,  indicating  the content  and sequence  of the jobDefiniteness ;to perform,  should be clearly specified.
Finiteness An algorithm  must be terminated  after execution
M1 Software  development  43


--- Page 45 ---
ESSENCE
Condition Description
Effectiveness All instructions  of the algorithm  should be basic and implementable.
B) Algorithm  analysis  criteria
@Correctness
The correct  result should be produced  for valid input by the algorithm  within a finite time.
@Amount  of work done:
The number  of instances  of execution  undertaken  to execute an algorithm;  The amount  of work done
should be measured  with important  operations  only that become  the core of the flow in the entire algorithm,
excluding  general  operations  included  by default.
@Amount  of space used:
An amount  of computer  memory  needed  to store data and information  while an algorithm  is being executed.
@  Optimality
The expression  “A certain algorithm  is optimal’ means that the algorithm  is the most appropriate  considering
the usage environment  (execution  times, memory  usage, ...
